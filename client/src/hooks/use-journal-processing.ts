import { useState, useCallback } from "react";
import { useMutation, useQueryClient, useQuery } from "@tanstack/react-query";
import { apiRequest } from "@/lib/queryClient";
import { processImageWithOCR, preprocessImageForOCR } from "@/lib/ocr";
import { useToast } from "@/hooks/use-toast";
import type { JournalEntryWithDetails } from "@shared/schema";

interface UploadResponse {
  id: number;
  message: string;
  imageUrl: string;
  processedImagePath?: string;
}

interface AnalysisResponse {
  themes: any[];
  sentiment: any;
  tags: any[];
  reflectionQuestions: string[];
}

export function useJournalProcessing() {
  const [currentEntry, setCurrentEntry] = useState<JournalEntryWithDetails | null>(null);
  const [isProcessing, setIsProcessing] = useState(false);
  const queryClient = useQueryClient();
  const { toast } = useToast();

  // Upload mutation
  const uploadMutation = useMutation({
    mutationFn: async ({ file, title }: { file: File; title: string }) => {
      console.log('Starting upload for file:', file.name, file.type, file.size);
      
      const formData = new FormData();
      formData.append('image', file);
      formData.append('title', title);

      console.log('FormData created, sending request...');
      const response = await apiRequest('POST', '/api/journal-entries/upload', formData);
      const result = await response.json() as UploadResponse;
      console.log('Upload successful:', result);
      return result;
    },
    onSuccess: (data) => {
      setCurrentEntry({
        id: data.id,
        title: 'Uploaded Entry',
        originalImageUrl: data.imageUrl,
        transcribedText: null,
        ocrConfidence: null,
        processingStatus: 'pending',
        userId: 1,
        createdAt: new Date(),
        updatedAt: new Date(),
        themes: [],
        tags: [],
        sentimentAnalysis: undefined
      } as any);
    },
    onError: (error) => {
      console.error('Upload error:', error);
      toast({
        title: "Upload failed",
        description: error instanceof Error ? error.message : "There was an error uploading your file.",
        variant: "destructive",
      });
    }
  });

  // Transcription mutation
  const transcriptionMutation = useMutation({
    mutationFn: async ({ entryId, transcribedText, confidence }: { 
      entryId: number; 
      transcribedText: string; 
      confidence: number; 
    }) => {
      const response = await apiRequest('POST', `/api/journal-entries/${entryId}/transcribe`, {
        transcribedText,
        confidence
      });
      return response.json();
    },
    onSuccess: (data, variables) => {
      setCurrentEntry(prev => prev ? {
        ...prev,
        transcribedText: variables.transcribedText,
        ocrConfidence: variables.confidence,
        processingStatus: 'processing'
      } : null);
    }
  });

  // Analysis mutation
  const analysisMutation = useMutation({
    mutationFn: async (entryId: number) => {
      const response = await apiRequest('POST', `/api/journal-entries/${entryId}/analyze`, {});
      return response.json() as Promise<AnalysisResponse>;
    },
    onSuccess: (data) => {
      setCurrentEntry(prev => prev ? {
        ...prev,
        themes: data.themes,
        tags: data.tags,
        sentimentAnalysis: data.sentiment,
        processingStatus: 'completed'
      } : null);
      
      // Invalidate recent entries query to refresh the list
      queryClient.invalidateQueries({ queryKey: ['/api/journal-entries'] });
    },
    onError: (error) => {
      console.error('Analysis error:', error);
      setCurrentEntry(prev => prev ? {
        ...prev,
        processingStatus: 'failed'
      } : null);
      toast({
        title: "Analysis failed",
        description: "There was an error analyzing your journal entry.",
        variant: "destructive",
      });
    }
  });

  // Add custom tag mutation
  const addTagMutation = useMutation({
    mutationFn: async ({ entryId, tagName, category }: { 
      entryId: number; 
      tagName: string; 
      category?: string; 
    }) => {
      const response = await apiRequest('POST', `/api/journal-entries/${entryId}/tags`, {
        tagName,
        category
      });
      return response.json();
    },
    onSuccess: (newTag, variables) => {
      setCurrentEntry(prev => prev ? {
        ...prev,
        tags: [...(prev.tags || []), { ...newTag, confidence: 100, isAutoGenerated: false }]
      } : null);
    }
  });

  // Main upload and process function
  const uploadFile = useCallback(async (file: File, title = "Untitled Entry") => {
    setIsProcessing(true);
    
    try {
      // 1. Upload file
      const uploadResult = await uploadMutation.mutateAsync({ file, title });
      
      // 2. Determine which image to use for OCR - server-converted if available, otherwise preprocess original
      let imageForOCR: File;
      if (uploadResult.processedImagePath) {
        // Use server-converted image
        const response = await fetch(uploadResult.processedImagePath);
        const blob = await response.blob();
        imageForOCR = new File([blob], file.name.replace(/\.heic$/i, '.jpg'), { type: 'image/jpeg' });
      } else {
        // Use preprocessed original image
        imageForOCR = await preprocessImageForOCR(file);
      }
      
      // 3. Process OCR
      const ocrResult = await processImageWithOCR(imageForOCR, (progress) => {
        console.log('OCR Progress:', progress);
      });

      // 4. Update with transcription
      await transcriptionMutation.mutateAsync({
        entryId: uploadResult.id,
        transcribedText: ocrResult.text,
        confidence: ocrResult.confidence
      });

      // 5. Analyze with AI
      await analysisMutation.mutateAsync(uploadResult.id);

      toast({
        title: "Processing complete",
        description: "Your journal entry has been successfully processed and analyzed.",
      });
    } catch (error) {
      console.error('Processing error:', error);
      toast({
        title: "Processing failed",
        description: "There was an error processing your journal entry.",
        variant: "destructive",
      });
    } finally {
      setIsProcessing(false);
    }
  }, [uploadMutation, transcriptionMutation, analysisMutation, toast]);

  // Function to update transcription
  const processTranscription = useCallback(async (transcription: string) => {
    if (!currentEntry) return;
    
    try {
      await transcriptionMutation.mutateAsync({
        entryId: currentEntry.id,
        transcribedText: transcription,
        confidence: currentEntry.ocrConfidence || 95
      });

      // Re-analyze after transcription update
      await analysisMutation.mutateAsync(currentEntry.id);
    } catch (error) {
      console.error('Transcription update error:', error);
    }
  }, [currentEntry, transcriptionMutation, analysisMutation]);

  // Function to analyze entry
  const analyzeEntry = useCallback(async () => {
    if (!currentEntry) return;
    
    try {
      await analysisMutation.mutateAsync(currentEntry.id);
    } catch (error) {
      console.error('Analysis error:', error);
    }
  }, [currentEntry, analysisMutation]);

  // Function to add custom tag
  const addCustomTag = useCallback(async (entryId: number, tagName: string, category?: string) => {
    try {
      await addTagMutation.mutateAsync({ entryId, tagName, category });
    } catch (error) {
      console.error('Add tag error:', error);
      throw error;
    }
  }, [addTagMutation]);

  return {
    currentEntry,
    isProcessing,
    uploadFile,
    processTranscription,
    analyzeEntry,
    addCustomTag,
    isUploading: uploadMutation.isPending,
    isTranscribing: transcriptionMutation.isPending,
    isAnalyzing: analysisMutation.isPending
  };
}
