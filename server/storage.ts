import { 
  users, 
  journalEntries, 
  themes, 
  tags, 
  entryTags, 
  sentimentAnalysis,
  type User, 
  type InsertUser,
  type JournalEntry,
  type InsertJournalEntry,
  type Theme,
  type InsertTheme,
  type Tag,
  type InsertTag,
  type EntryTag,
  type InsertEntryTag,
  type SentimentAnalysis,
  type InsertSentimentAnalysis,
  type JournalEntryWithDetails
} from "@shared/schema";
import { db } from "./db";
import { eq, desc, and } from "drizzle-orm";

export interface IStorage {
  // User methods
  getUser(id: number): Promise<User | undefined>;
  getUserByUsername(username: string): Promise<User | undefined>;
  createUser(user: InsertUser): Promise<User>;

  // Journal entry methods
  createJournalEntry(entry: InsertJournalEntry): Promise<JournalEntry>;
  updateJournalEntry(id: number, updates: Partial<InsertJournalEntry>): Promise<JournalEntry>;
  getJournalEntry(id: number): Promise<JournalEntryWithDetails | undefined>;
  getJournalEntriesByUser(userId: number, limit?: number): Promise<JournalEntryWithDetails[]>;

  // Theme methods
  createTheme(theme: InsertTheme): Promise<Theme>;
  getThemesByEntry(entryId: number): Promise<Theme[]>;

  // Tag methods
  createTag(tag: InsertTag): Promise<Tag>;
  getTagByName(name: string): Promise<Tag | undefined>;
  getAllTags(): Promise<Tag[]>;
  getOrCreateTag(name: string, category?: string, isCustom?: boolean): Promise<Tag>;

  // Entry tag methods
  addTagToEntry(entryTag: InsertEntryTag): Promise<EntryTag>;
  getTagsByEntry(entryId: number): Promise<(Tag & { confidence?: number; isAutoGenerated?: boolean })[]>;

  // Sentiment analysis methods
  createSentimentAnalysis(sentiment: InsertSentimentAnalysis): Promise<SentimentAnalysis>;
  getSentimentByEntry(entryId: number): Promise<SentimentAnalysis | undefined>;
}

export class DatabaseStorage implements IStorage {
  async getUser(id: number): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user || undefined;
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.username, username));
    return user || undefined;
  }

  async createUser(insertUser: InsertUser): Promise<User> {
    const [user] = await db
      .insert(users)
      .values(insertUser)
      .returning();
    return user;
  }

  async createJournalEntry(entry: InsertJournalEntry): Promise<JournalEntry> {
    const [journalEntry] = await db
      .insert(journalEntries)
      .values(entry)
      .returning();
    return journalEntry;
  }

  async updateJournalEntry(id: number, updates: Partial<InsertJournalEntry>): Promise<JournalEntry> {
    const [journalEntry] = await db
      .update(journalEntries)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(journalEntries.id, id))
      .returning();
    return journalEntry;
  }

  async getJournalEntry(id: number): Promise<JournalEntryWithDetails | undefined> {
    const [entry] = await db.select().from(journalEntries).where(eq(journalEntries.id, id));
    if (!entry) return undefined;

    const [entryThemes, entryTagsData, sentiment] = await Promise.all([
      this.getThemesByEntry(id),
      this.getTagsByEntry(id),
      this.getSentimentByEntry(id)
    ]);

    return {
      ...entry,
      themes: entryThemes,
      tags: entryTagsData,
      sentimentAnalysis: sentiment
    };
  }

  async getJournalEntriesByUser(userId: number, limit = 10): Promise<JournalEntryWithDetails[]> {
    const entries = await db
      .select()
      .from(journalEntries)
      .where(eq(journalEntries.userId, userId))
      .orderBy(desc(journalEntries.createdAt))
      .limit(limit);

    const entriesWithDetails = await Promise.all(
      entries.map(async (entry) => {
        const [entryThemes, entryTagsData, sentiment] = await Promise.all([
          this.getThemesByEntry(entry.id),
          this.getTagsByEntry(entry.id),
          this.getSentimentByEntry(entry.id)
        ]);

        return {
          ...entry,
          themes: entryThemes,
          tags: entryTagsData,
          sentimentAnalysis: sentiment
        };
      })
    );

    return entriesWithDetails;
  }

  async createTheme(theme: InsertTheme): Promise<Theme> {
    const [createdTheme] = await db
      .insert(themes)
      .values(theme)
      .returning();
    return createdTheme;
  }

  async getThemesByEntry(entryId: number): Promise<Theme[]> {
    return await db
      .select()
      .from(themes)
      .where(eq(themes.entryId, entryId));
  }

  async createTag(tag: InsertTag): Promise<Tag> {
    const [createdTag] = await db
      .insert(tags)
      .values(tag)
      .returning();
    return createdTag;
  }

  async getTagByName(name: string): Promise<Tag | undefined> {
    const [tag] = await db.select().from(tags).where(eq(tags.name, name));
    return tag || undefined;
  }

  async getAllTags(): Promise<Tag[]> {
    return await db.select().from(tags);
  }

  async getOrCreateTag(name: string, category?: string, isCustom = false): Promise<Tag> {
    const existingTag = await this.getTagByName(name);
    if (existingTag) {
      return existingTag;
    }

    return await this.createTag({
      name,
      category,
      isCustom
    });
  }

  async addTagToEntry(entryTag: InsertEntryTag): Promise<EntryTag> {
    const [createdEntryTag] = await db
      .insert(entryTags)
      .values(entryTag)
      .returning();
    return createdEntryTag;
  }

  async getTagsByEntry(entryId: number): Promise<(Tag & { confidence?: number; isAutoGenerated?: boolean })[]> {
    const result = await db
      .select({
        id: tags.id,
        name: tags.name,
        category: tags.category,
        color: tags.color,
        isCustom: tags.isCustom,
        createdAt: tags.createdAt,
        confidence: entryTags.confidence,
        isAutoGenerated: entryTags.isAutoGenerated
      })
      .from(entryTags)
      .innerJoin(tags, eq(entryTags.tagId, tags.id))
      .where(eq(entryTags.entryId, entryId));

    return result;
  }

  async createSentimentAnalysis(sentiment: InsertSentimentAnalysis): Promise<SentimentAnalysis> {
    const [createdSentiment] = await db
      .insert(sentimentAnalysis)
      .values(sentiment)
      .returning();
    return createdSentiment;
  }

  async getSentimentByEntry(entryId: number): Promise<SentimentAnalysis | undefined> {
    const [sentiment] = await db
      .select()
      .from(sentimentAnalysis)
      .where(eq(sentimentAnalysis.entryId, entryId));
    return sentiment || undefined;
  }
}

export const storage = new DatabaseStorage();
