import { 
  users, 
  journalEntries, 
  themes, 
  tags, 
  entryTags, 
  sentimentAnalysis,
  userIntegrations,
  notionEntries,
  googleDocsCredentials,
  googleDocsEntries,
  type User, 
  type InsertUser,
  type JournalEntry,
  type InsertJournalEntry,
  type Theme,
  type InsertTheme,
  type Tag,
  type InsertTag,
  type EntryTag,
  type InsertEntryTag,
  type SentimentAnalysis,
  type InsertSentimentAnalysis,
  type UserIntegration,
  type InsertUserIntegration,
  type NotionEntry,
  type InsertNotionEntry,
  type GoogleDocsCredentials,
  type InsertGoogleDocsCredentials,
  type GoogleDocsEntry,
  type InsertGoogleDocsEntry,
  type JournalEntryWithDetails
} from "@shared/schema";
import { db } from "./db";
import { eq, desc, and, or, isNull } from "drizzle-orm";

export interface IStorage {
  // User methods
  getUser(id: number): Promise<User | undefined>;
  getUserByUsername(username: string): Promise<User | undefined>;
  createUser(user: InsertUser): Promise<User>;

  // Journal entry methods
  createJournalEntry(entry: InsertJournalEntry): Promise<JournalEntry>;
  updateJournalEntry(id: number, updates: Partial<InsertJournalEntry>): Promise<JournalEntry>;
  getJournalEntry(id: number): Promise<JournalEntryWithDetails | undefined>;
  getJournalEntriesByUser(userId: number, limit?: number): Promise<JournalEntryWithDetails[]>;

  // Theme methods
  createTheme(theme: InsertTheme): Promise<Theme>;
  getThemesByEntry(entryId: number): Promise<Theme[]>;

  // Tag methods
  createTag(tag: InsertTag): Promise<Tag>;
  getTagByName(name: string): Promise<Tag | undefined>;
  getAllTags(): Promise<Tag[]>;
  getOrCreateTag(name: string, category?: string, isCustom?: boolean): Promise<Tag>;

  // Entry tag methods
  addTagToEntry(entryTag: InsertEntryTag): Promise<EntryTag>;
  getTagsByEntry(entryId: number): Promise<(Tag & { confidence?: number; isAutoGenerated?: boolean })[]>;

  // Sentiment analysis methods
  createSentimentAnalysis(sentiment: InsertSentimentAnalysis): Promise<SentimentAnalysis>;
  getSentimentByEntry(entryId: number): Promise<SentimentAnalysis | undefined>;

  // Failed entries methods
  getFailedEntries(): Promise<JournalEntry[]>;

  // Delete journal entry
  deleteJournalEntry(id: number): Promise<void>;

  // Merge journal entries
  mergeJournalEntries(
    userId: number, 
    entryIds: number[], 
    mergedTitle: string, 
    regenerateAnalysis?: boolean
  ): Promise<JournalEntry>;

  // User integration methods
  createUserIntegration(integration: InsertUserIntegration): Promise<UserIntegration>;
  updateUserIntegration(userId: number, integrationType: string, updates: Partial<InsertUserIntegration>): Promise<UserIntegration>;
  getUserIntegration(userId: number, integrationType: string): Promise<UserIntegration | undefined>;
  getUserIntegrations(userId: number): Promise<UserIntegration[]>;

  // Notion entries methods
  createNotionEntry(entry: InsertNotionEntry): Promise<NotionEntry>;
  updateNotionEntry(id: number, updates: Partial<InsertNotionEntry>): Promise<NotionEntry>;
  getNotionEntryByJournalId(journalEntryId: number): Promise<NotionEntry | undefined>;
  getNotionEntriesByUser(userId: number): Promise<NotionEntry[]>;

  // Google Docs credentials methods
  createGoogleDocsCredentials(credentials: InsertGoogleDocsCredentials): Promise<GoogleDocsCredentials>;
  updateGoogleDocsCredentials(userId: number, updates: Partial<InsertGoogleDocsCredentials>): Promise<GoogleDocsCredentials>;
  getGoogleDocsCredentials(userId: number): Promise<GoogleDocsCredentials | undefined>;
  deleteGoogleDocsCredentials(userId: number): Promise<void>;

  // Google Docs entries methods
  createGoogleDocsEntry(entry: InsertGoogleDocsEntry): Promise<GoogleDocsEntry>;
  updateGoogleDocsEntry(id: number, updates: Partial<InsertGoogleDocsEntry>): Promise<GoogleDocsEntry>;
  getGoogleDocsEntryByJournalId(journalEntryId: number): Promise<GoogleDocsEntry | undefined>;
  getGoogleDocsEntriesByUser(userId: number): Promise<GoogleDocsEntry[]>;
  getLastGoogleDocsEntryByUser(userId: number): Promise<GoogleDocsEntry | undefined>;
}

export class DatabaseStorage implements IStorage {
  async getUser(id: number): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user || undefined;
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.username, username));
    return user || undefined;
  }

  async createUser(insertUser: InsertUser): Promise<User> {
    const [user] = await db
      .insert(users)
      .values(insertUser)
      .returning();
    return user;
  }

  async createJournalEntry(entry: InsertJournalEntry): Promise<JournalEntry> {
    const [journalEntry] = await db
      .insert(journalEntries)
      .values(entry)
      .returning();
    return journalEntry;
  }

  async updateJournalEntry(id: number, updates: Partial<InsertJournalEntry>): Promise<JournalEntry> {
    const [journalEntry] = await db
      .update(journalEntries)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(journalEntries.id, id))
      .returning();
    return journalEntry;
  }

  async getJournalEntry(id: number): Promise<JournalEntryWithDetails | undefined> {
    const [entry] = await db.select().from(journalEntries).where(eq(journalEntries.id, id));
    if (!entry) return undefined;

    const [entryThemes, entryTagsData, sentiment] = await Promise.all([
      this.getThemesByEntry(id),
      this.getTagsByEntry(id),
      this.getSentimentByEntry(id)
    ]);

    return {
      ...entry,
      themes: entryThemes,
      tags: entryTagsData,
      sentimentAnalysis: sentiment
    };
  }

  async getJournalEntriesByUser(userId: number, limit = 10): Promise<JournalEntryWithDetails[]> {
    console.log(`Fetching journal entries for user ${userId} with limit ${limit}`);
    
    const entries = await db
      .select()
      .from(journalEntries)
      .where(eq(journalEntries.userId, userId))
      .orderBy(desc(journalEntries.createdAt))
      .limit(limit);

    console.log(`Found ${entries.length} entries for user ${userId}`);

    const entriesWithDetails = await Promise.all(
      entries.map(async (entry) => {
        try {
          const [entryThemes, entryTagsData, sentiment] = await Promise.all([
            this.getThemesByEntry(entry.id),
            this.getTagsByEntry(entry.id),
            this.getSentimentByEntry(entry.id)
          ]);

          return {
            ...entry,
            themes: entryThemes,
            tags: entryTagsData,
            sentimentAnalysis: sentiment
          };
        } catch (error) {
          console.error(`Error processing entry ${entry.id}:`, error);
          return {
            ...entry,
            themes: [],
            tags: [],
            sentimentAnalysis: undefined
          };
        }
      })
    );

    console.log(`Returning ${entriesWithDetails.length} entries with details`);
    return entriesWithDetails;
  }

  async createTheme(theme: InsertTheme): Promise<Theme> {
    const [createdTheme] = await db
      .insert(themes)
      .values(theme)
      .returning();
    return createdTheme;
  }

  async getThemesByEntry(entryId: number): Promise<Theme[]> {
    return await db
      .select()
      .from(themes)
      .where(eq(themes.entryId, entryId));
  }

  async createTag(tag: InsertTag): Promise<Tag> {
    const [createdTag] = await db
      .insert(tags)
      .values(tag)
      .returning();
    return createdTag;
  }

  async getTagByName(name: string): Promise<Tag | undefined> {
    const [tag] = await db.select().from(tags).where(eq(tags.name, name));
    return tag || undefined;
  }

  async getAllTags(): Promise<Tag[]> {
    return await db.select().from(tags);
  }

  async getOrCreateTag(name: string, category?: string, isCustom = false): Promise<Tag> {
    const existingTag = await this.getTagByName(name);
    if (existingTag) {
      return existingTag;
    }

    return await this.createTag({
      name,
      category,
      isCustom
    });
  }

  async addTagToEntry(entryTag: InsertEntryTag): Promise<EntryTag> {
    const [createdEntryTag] = await db
      .insert(entryTags)
      .values(entryTag)
      .returning();
    return createdEntryTag;
  }

  async getTagsByEntry(entryId: number): Promise<(Tag & { confidence?: number; isAutoGenerated?: boolean })[]> {
    const result = await db
      .select({
        id: tags.id,
        name: tags.name,
        category: tags.category,
        color: tags.color,
        isCustom: tags.isCustom,
        createdAt: tags.createdAt,
        confidence: entryTags.confidence,
        isAutoGenerated: entryTags.isAutoGenerated
      })
      .from(entryTags)
      .innerJoin(tags, eq(entryTags.tagId, tags.id))
      .where(eq(entryTags.entryId, entryId));

    return result.map(item => ({
      id: item.id,
      name: item.name,
      category: item.category,
      color: item.color,
      isCustom: item.isCustom,
      createdAt: item.createdAt,
      confidence: item.confidence ? Number(item.confidence) : undefined,
      isAutoGenerated: item.isAutoGenerated ?? undefined
    }));
  }

  async createSentimentAnalysis(sentiment: InsertSentimentAnalysis): Promise<SentimentAnalysis> {
    const [createdSentiment] = await db
      .insert(sentimentAnalysis)
      .values(sentiment)
      .returning();
    return createdSentiment;
  }

  async getSentimentByEntry(entryId: number): Promise<SentimentAnalysis | undefined> {
    const [sentiment] = await db
      .select()
      .from(sentimentAnalysis)
      .where(eq(sentimentAnalysis.entryId, entryId));
    return sentiment || undefined;
  }

  async getFailedEntries(): Promise<JournalEntry[]> {
    const entries = await db
      .select()
      .from(journalEntries)
      .where(eq(journalEntries.processingStatus, 'pending'))
      .orderBy(desc(journalEntries.createdAt));
    
    return entries;
  }

  async deleteJournalEntry(id: number): Promise<void> {
    await db.delete(journalEntries).where(eq(journalEntries.id, id));
  }

  async mergeJournalEntries(
    userId: number, 
    entryIds: number[], 
    mergedTitle: string, 
    regenerateAnalysis: boolean = false
  ): Promise<JournalEntry> {
    // Fetch all entries to merge
    const entries = await Promise.all(
      entryIds.map(id => this.getJournalEntry(id))
    );

    // Filter out entries that don't exist or don't belong to the user
    const validEntries = entries.filter(entry => entry && entry.userId === userId);
    
    if (validEntries.length < 2) {
      throw new Error("At least 2 valid entries are required for merging");
    }

    // Sort entries by creation date for consistent merging order
    validEntries.sort((a, b) => new Date(a!.createdAt).getTime() - new Date(b!.createdAt).getTime());

    // Combine transcribed text
    const mergedTranscript = validEntries
      .map(entry => entry!.transcribedText)
      .filter(text => text && text.trim())
      .join('\n\n---\n\n');

    // Combine image URLs (take first non-null one for primary, store others as merged info)
    const primaryImageUrl = validEntries.find(entry => entry!.originalImageUrl)?.originalImageUrl || null;

    // Calculate average OCR confidence
    const confidences = validEntries
      .map(entry => entry!.ocrConfidence)
      .filter(conf => conf !== null && conf !== undefined);
    const avgConfidence = confidences.length > 0 
      ? Math.round(confidences.reduce((sum, conf) => sum + conf!, 0) / confidences.length)
      : null;

    // Use the earliest entry date
    const earliestDate = validEntries
      .map(entry => entry!.entryDate)
      .filter(date => date !== null)
      .sort((a, b) => new Date(a!).getTime() - new Date(b!).getTime())[0] || null;

    // Create the merged entry
    const mergedEntry = await this.createJournalEntry({
      userId,
      title: mergedTitle,
      originalImageUrl: primaryImageUrl,
      transcribedText: mergedTranscript,
      ocrConfidence: avgConfidence,
      processingStatus: 'completed',
      entryDate: earliestDate,
      mergedFromIds: validEntries.map(entry => entry!.id)
    });

    // Collect and merge tags (deduplicate)
    const allTags = new Map<string, { tag: Tag; confidence?: number; isAutoGenerated?: boolean }>();
    
    for (const entry of validEntries) {
      const entryTags = await this.getTagsByEntry(entry!.id);
      for (const tag of entryTags) {
        const key = tag.name.toLowerCase();
        if (!allTags.has(key) || (tag.confidence && tag.confidence > (allTags.get(key)?.confidence || 0))) {
          allTags.set(key, { tag, confidence: tag.confidence, isAutoGenerated: tag.isAutoGenerated });
        }
      }
    }

    // Add merged tags to the new entry
    for (const { tag, confidence, isAutoGenerated } of allTags.values()) {
      await this.addTagToEntry({
        entryId: mergedEntry.id,
        tagId: tag.id,
        confidence: confidence || null,
        isAutoGenerated: isAutoGenerated || false
      });
    }

    // Collect and merge themes
    const allThemes = [];
    for (const entry of validEntries) {
      const entryThemes = await this.getThemesByEntry(entry!.id);
      allThemes.push(...entryThemes);
    }

    // Add themes to merged entry (could deduplicate by title if needed)
    for (const theme of allThemes) {
      await this.createTheme({
        entryId: mergedEntry.id,
        title: theme.title,
        description: theme.description,
        confidence: theme.confidence
      });
    }

    // Handle sentiment analysis - use the most recent or average
    const sentiments = await Promise.all(
      validEntries.map(entry => this.getSentimentByEntry(entry!.id))
    );
    const validSentiments = sentiments.filter(s => s !== undefined);
    
    if (validSentiments.length > 0) {
      // Use average sentiment scores
      const avgPositive = Math.round(validSentiments.reduce((sum, s) => sum + s!.positiveScore, 0) / validSentiments.length);
      const avgNeutral = Math.round(validSentiments.reduce((sum, s) => sum + s!.neutralScore, 0) / validSentiments.length);
      const avgConcern = Math.round(validSentiments.reduce((sum, s) => sum + s!.concernScore, 0) / validSentiments.length);
      
      // Determine overall sentiment based on highest average
      let overallSentiment = 'neutral';
      if (avgPositive > avgNeutral && avgPositive > avgConcern) {
        overallSentiment = 'positive';
      } else if (avgConcern > avgPositive && avgConcern > avgNeutral) {
        overallSentiment = 'negative';
      }

      await this.createSentimentAnalysis({
        entryId: mergedEntry.id,
        positiveScore: avgPositive,
        neutralScore: avgNeutral,
        concernScore: avgConcern,
        overallSentiment
      });
    }

    return mergedEntry;
  }

  // User integration methods
  async createUserIntegration(integration: InsertUserIntegration): Promise<UserIntegration> {
    const [result] = await db
      .insert(userIntegrations)
      .values(integration)
      .returning();
    return result;
  }

  async updateUserIntegration(userId: number, integrationType: string, updates: Partial<InsertUserIntegration>): Promise<UserIntegration> {
    const [result] = await db
      .update(userIntegrations)
      .set({ ...updates, updatedAt: new Date() })
      .where(and(
        eq(userIntegrations.userId, userId),
        eq(userIntegrations.integrationType, integrationType)
      ))
      .returning();
    return result;
  }

  async getUserIntegration(userId: number, integrationType: string): Promise<UserIntegration | undefined> {
    const [integration] = await db
      .select()
      .from(userIntegrations)
      .where(and(
        eq(userIntegrations.userId, userId),
        eq(userIntegrations.integrationType, integrationType)
      ));
    return integration || undefined;
  }

  async getUserIntegrations(userId: number): Promise<UserIntegration[]> {
    return await db
      .select()
      .from(userIntegrations)
      .where(eq(userIntegrations.userId, userId))
      .orderBy(desc(userIntegrations.createdAt));
  }

  // Notion entries methods
  async createNotionEntry(entry: InsertNotionEntry): Promise<NotionEntry> {
    const [result] = await db
      .insert(notionEntries)
      .values(entry)
      .returning();
    return result;
  }

  async updateNotionEntry(id: number, updates: Partial<InsertNotionEntry>): Promise<NotionEntry> {
    const [result] = await db
      .update(notionEntries)
      .set(updates)
      .where(eq(notionEntries.id, id))
      .returning();
    return result;
  }

  async getNotionEntryByJournalId(journalEntryId: number): Promise<NotionEntry | undefined> {
    const [entry] = await db
      .select()
      .from(notionEntries)
      .where(eq(notionEntries.journalEntryId, journalEntryId));
    return entry || undefined;
  }

  async getNotionEntriesByUser(userId: number): Promise<NotionEntry[]> {
    return await db
      .select()
      .from(notionEntries)
      .where(eq(notionEntries.userId, userId))
      .orderBy(desc(notionEntries.createdAt));
  }

  // Google Docs Credentials methods
  async createGoogleDocsCredentials(credentials: InsertGoogleDocsCredentials): Promise<GoogleDocsCredentials> {
    const [result] = await db
      .insert(googleDocsCredentials)
      .values(credentials)
      .returning();
    return result;
  }

  async updateGoogleDocsCredentials(userId: number, updates: Partial<InsertGoogleDocsCredentials>): Promise<GoogleDocsCredentials> {
    const [result] = await db
      .update(googleDocsCredentials)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(googleDocsCredentials.userId, userId))
      .returning();
    return result;
  }

  async getGoogleDocsCredentials(userId: number): Promise<GoogleDocsCredentials | undefined> {
    const [credentials] = await db
      .select()
      .from(googleDocsCredentials)
      .where(eq(googleDocsCredentials.userId, userId));
    return credentials || undefined;
  }

  async deleteGoogleDocsCredentials(userId: number): Promise<void> {
    await db
      .delete(googleDocsCredentials)
      .where(eq(googleDocsCredentials.userId, userId));
  }

  // Google Docs Entries methods
  async createGoogleDocsEntry(entry: InsertGoogleDocsEntry): Promise<GoogleDocsEntry> {
    const [result] = await db
      .insert(googleDocsEntries)
      .values(entry)
      .returning();
    return result;
  }

  async updateGoogleDocsEntry(id: number, updates: Partial<InsertGoogleDocsEntry>): Promise<GoogleDocsEntry> {
    const [result] = await db
      .update(googleDocsEntries)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(googleDocsEntries.id, id))
      .returning();
    return result;
  }

  async getGoogleDocsEntryByJournalId(journalEntryId: number): Promise<GoogleDocsEntry | undefined> {
    const [entry] = await db
      .select()
      .from(googleDocsEntries)
      .where(eq(googleDocsEntries.journalEntryId, journalEntryId));
    return entry || undefined;
  }

  async getGoogleDocsEntriesByUser(userId: number): Promise<GoogleDocsEntry[]> {
    return await db
      .select()
      .from(googleDocsEntries)
      .where(eq(googleDocsEntries.userId, userId))
      .orderBy(desc(googleDocsEntries.createdAt));
  }

  async getLastGoogleDocsEntryByUser(userId: number): Promise<GoogleDocsEntry | undefined> {
    const [entry] = await db
      .select()
      .from(googleDocsEntries)
      .where(eq(googleDocsEntries.userId, userId))
      .orderBy(desc(googleDocsEntries.createdAt))
      .limit(1);
    return entry || undefined;
  }
}

export const storage = new DatabaseStorage();
