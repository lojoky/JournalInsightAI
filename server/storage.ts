import { 
  users, 
  journalEntries, 
  themes, 
  tags, 
  entryTags, 
  sentimentAnalysis,
  userIntegrations,
  notionEntries,
  googleDocs,
  type User, 
  type InsertUser,
  type JournalEntry,
  type InsertJournalEntry,
  type Theme,
  type InsertTheme,
  type Tag,
  type InsertTag,
  type EntryTag,
  type InsertEntryTag,
  type SentimentAnalysis,
  type InsertSentimentAnalysis,
  type UserIntegration,
  type InsertUserIntegration,
  type NotionEntry,
  type InsertNotionEntry,
  type GoogleDoc,
  type InsertGoogleDoc,
  type JournalEntryWithDetails
} from "@shared/schema";
import { db } from "./db";
import { eq, desc, and, or, isNull } from "drizzle-orm";

export interface IStorage {
  // User methods
  getUser(id: number): Promise<User | undefined>;
  getUserByUsername(username: string): Promise<User | undefined>;
  createUser(user: InsertUser): Promise<User>;

  // Journal entry methods
  createJournalEntry(entry: InsertJournalEntry): Promise<JournalEntry>;
  updateJournalEntry(id: number, updates: Partial<InsertJournalEntry>): Promise<JournalEntry>;
  getJournalEntry(id: number): Promise<JournalEntryWithDetails | undefined>;
  getJournalEntriesByUser(userId: number, limit?: number): Promise<JournalEntryWithDetails[]>;

  // Theme methods
  createTheme(theme: InsertTheme): Promise<Theme>;
  getThemesByEntry(entryId: number): Promise<Theme[]>;

  // Tag methods
  createTag(tag: InsertTag): Promise<Tag>;
  getTagByName(name: string): Promise<Tag | undefined>;
  getAllTags(): Promise<Tag[]>;
  getOrCreateTag(name: string, category?: string, isCustom?: boolean): Promise<Tag>;

  // Entry tag methods
  addTagToEntry(entryTag: InsertEntryTag): Promise<EntryTag>;
  getTagsByEntry(entryId: number): Promise<(Tag & { confidence?: number; isAutoGenerated?: boolean })[]>;

  // Sentiment analysis methods
  createSentimentAnalysis(sentiment: InsertSentimentAnalysis): Promise<SentimentAnalysis>;
  getSentimentByEntry(entryId: number): Promise<SentimentAnalysis | undefined>;

  // Failed entries methods
  getFailedEntries(): Promise<JournalEntry[]>;

  // User integration methods
  createUserIntegration(integration: InsertUserIntegration): Promise<UserIntegration>;
  updateUserIntegration(userId: number, integrationType: string, updates: Partial<InsertUserIntegration>): Promise<UserIntegration>;
  getUserIntegration(userId: number, integrationType: string): Promise<UserIntegration | undefined>;
  getUserIntegrations(userId: number): Promise<UserIntegration[]>;

  // Notion entries methods
  createNotionEntry(entry: InsertNotionEntry): Promise<NotionEntry>;
  updateNotionEntry(id: number, updates: Partial<InsertNotionEntry>): Promise<NotionEntry>;
  getNotionEntryByJournalId(journalEntryId: number): Promise<NotionEntry | undefined>;
  getNotionEntriesByUser(userId: number): Promise<NotionEntry[]>;

  // Google Docs methods
  createGoogleDoc(entry: InsertGoogleDoc): Promise<GoogleDoc>;
  updateGoogleDoc(id: number, updates: Partial<InsertGoogleDoc>): Promise<GoogleDoc>;
  getGoogleDocByJournalId(journalEntryId: number): Promise<GoogleDoc | undefined>;
  getGoogleDocsByUser(userId: number): Promise<GoogleDoc[]>;
}

export class DatabaseStorage implements IStorage {
  async getUser(id: number): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user || undefined;
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.username, username));
    return user || undefined;
  }

  async createUser(insertUser: InsertUser): Promise<User> {
    const [user] = await db
      .insert(users)
      .values(insertUser)
      .returning();
    return user;
  }

  async createJournalEntry(entry: InsertJournalEntry): Promise<JournalEntry> {
    const [journalEntry] = await db
      .insert(journalEntries)
      .values(entry)
      .returning();
    return journalEntry;
  }

  async updateJournalEntry(id: number, updates: Partial<InsertJournalEntry>): Promise<JournalEntry> {
    const [journalEntry] = await db
      .update(journalEntries)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(journalEntries.id, id))
      .returning();
    return journalEntry;
  }

  async getJournalEntry(id: number): Promise<JournalEntryWithDetails | undefined> {
    const [entry] = await db.select().from(journalEntries).where(eq(journalEntries.id, id));
    if (!entry) return undefined;

    const [entryThemes, entryTagsData, sentiment] = await Promise.all([
      this.getThemesByEntry(id),
      this.getTagsByEntry(id),
      this.getSentimentByEntry(id)
    ]);

    return {
      ...entry,
      themes: entryThemes,
      tags: entryTagsData,
      sentimentAnalysis: sentiment
    };
  }

  async getJournalEntriesByUser(userId: number, limit = 10): Promise<JournalEntryWithDetails[]> {
    console.log(`Fetching journal entries for user ${userId} with limit ${limit}`);
    
    const entries = await db
      .select()
      .from(journalEntries)
      .where(eq(journalEntries.userId, userId))
      .orderBy(desc(journalEntries.createdAt))
      .limit(limit);

    console.log(`Found ${entries.length} entries for user ${userId}`);

    const entriesWithDetails = await Promise.all(
      entries.map(async (entry) => {
        try {
          const [entryThemes, entryTagsData, sentiment] = await Promise.all([
            this.getThemesByEntry(entry.id),
            this.getTagsByEntry(entry.id),
            this.getSentimentByEntry(entry.id)
          ]);

          return {
            ...entry,
            themes: entryThemes,
            tags: entryTagsData,
            sentimentAnalysis: sentiment
          };
        } catch (error) {
          console.error(`Error processing entry ${entry.id}:`, error);
          return {
            ...entry,
            themes: [],
            tags: [],
            sentimentAnalysis: undefined
          };
        }
      })
    );

    console.log(`Returning ${entriesWithDetails.length} entries with details`);
    return entriesWithDetails;
  }

  async createTheme(theme: InsertTheme): Promise<Theme> {
    const [createdTheme] = await db
      .insert(themes)
      .values(theme)
      .returning();
    return createdTheme;
  }

  async getThemesByEntry(entryId: number): Promise<Theme[]> {
    return await db
      .select()
      .from(themes)
      .where(eq(themes.entryId, entryId));
  }

  async createTag(tag: InsertTag): Promise<Tag> {
    const [createdTag] = await db
      .insert(tags)
      .values(tag)
      .returning();
    return createdTag;
  }

  async getTagByName(name: string): Promise<Tag | undefined> {
    const [tag] = await db.select().from(tags).where(eq(tags.name, name));
    return tag || undefined;
  }

  async getAllTags(): Promise<Tag[]> {
    return await db.select().from(tags);
  }

  async getOrCreateTag(name: string, category?: string, isCustom = false): Promise<Tag> {
    const existingTag = await this.getTagByName(name);
    if (existingTag) {
      return existingTag;
    }

    return await this.createTag({
      name,
      category,
      isCustom
    });
  }

  async addTagToEntry(entryTag: InsertEntryTag): Promise<EntryTag> {
    const [createdEntryTag] = await db
      .insert(entryTags)
      .values(entryTag)
      .returning();
    return createdEntryTag;
  }

  async getTagsByEntry(entryId: number): Promise<(Tag & { confidence?: number; isAutoGenerated?: boolean })[]> {
    const result = await db
      .select({
        id: tags.id,
        name: tags.name,
        category: tags.category,
        color: tags.color,
        isCustom: tags.isCustom,
        createdAt: tags.createdAt,
        confidence: entryTags.confidence,
        isAutoGenerated: entryTags.isAutoGenerated
      })
      .from(entryTags)
      .innerJoin(tags, eq(entryTags.tagId, tags.id))
      .where(eq(entryTags.entryId, entryId));

    return result.map(item => ({
      id: item.id,
      name: item.name,
      category: item.category,
      color: item.color,
      isCustom: item.isCustom,
      createdAt: item.createdAt,
      confidence: item.confidence ?? undefined,
      isAutoGenerated: item.isAutoGenerated ?? undefined
    }));
  }

  async createSentimentAnalysis(sentiment: InsertSentimentAnalysis): Promise<SentimentAnalysis> {
    const [createdSentiment] = await db
      .insert(sentimentAnalysis)
      .values(sentiment)
      .returning();
    return createdSentiment;
  }

  async getSentimentByEntry(entryId: number): Promise<SentimentAnalysis | undefined> {
    const [sentiment] = await db
      .select()
      .from(sentimentAnalysis)
      .where(eq(sentimentAnalysis.entryId, entryId));
    return sentiment || undefined;
  }

  async getFailedEntries(): Promise<JournalEntry[]> {
    const entries = await db
      .select()
      .from(journalEntries)
      .where(eq(journalEntries.processingStatus, 'pending'))
      .orderBy(desc(journalEntries.createdAt));
    
    return entries;
  }

  // User integration methods
  async createUserIntegration(integration: InsertUserIntegration): Promise<UserIntegration> {
    const [result] = await db
      .insert(userIntegrations)
      .values(integration)
      .returning();
    return result;
  }

  async updateUserIntegration(userId: number, integrationType: string, updates: Partial<InsertUserIntegration>): Promise<UserIntegration> {
    const [result] = await db
      .update(userIntegrations)
      .set({ ...updates, updatedAt: new Date() })
      .where(and(
        eq(userIntegrations.userId, userId),
        eq(userIntegrations.integrationType, integrationType)
      ))
      .returning();
    return result;
  }

  async getUserIntegration(userId: number, integrationType: string): Promise<UserIntegration | undefined> {
    const [integration] = await db
      .select()
      .from(userIntegrations)
      .where(and(
        eq(userIntegrations.userId, userId),
        eq(userIntegrations.integrationType, integrationType)
      ));
    return integration || undefined;
  }

  async getUserIntegrations(userId: number): Promise<UserIntegration[]> {
    return await db
      .select()
      .from(userIntegrations)
      .where(eq(userIntegrations.userId, userId))
      .orderBy(desc(userIntegrations.createdAt));
  }

  // Notion entries methods
  async createNotionEntry(entry: InsertNotionEntry): Promise<NotionEntry> {
    const [result] = await db
      .insert(notionEntries)
      .values(entry)
      .returning();
    return result;
  }

  async updateNotionEntry(id: number, updates: Partial<InsertNotionEntry>): Promise<NotionEntry> {
    const [result] = await db
      .update(notionEntries)
      .set(updates)
      .where(eq(notionEntries.id, id))
      .returning();
    return result;
  }

  async getNotionEntryByJournalId(journalEntryId: number): Promise<NotionEntry | undefined> {
    const [entry] = await db
      .select()
      .from(notionEntries)
      .where(eq(notionEntries.journalEntryId, journalEntryId));
    return entry || undefined;
  }

  async getNotionEntriesByUser(userId: number): Promise<NotionEntry[]> {
    return await db
      .select()
      .from(notionEntries)
      .where(eq(notionEntries.userId, userId))
      .orderBy(desc(notionEntries.createdAt));
  }

  // Google Docs methods
  async createGoogleDoc(entry: InsertGoogleDoc): Promise<GoogleDoc> {
    const [result] = await db
      .insert(googleDocs)
      .values(entry)
      .returning();
    return result;
  }

  async updateGoogleDoc(id: number, updates: Partial<InsertGoogleDoc>): Promise<GoogleDoc> {
    const [result] = await db
      .update(googleDocs)
      .set(updates)
      .where(eq(googleDocs.id, id))
      .returning();
    return result;
  }

  async getGoogleDocByJournalId(journalEntryId: number): Promise<GoogleDoc | undefined> {
    const [entry] = await db
      .select()
      .from(googleDocs)
      .where(eq(googleDocs.journalEntryId, journalEntryId));
    return entry || undefined;
  }

  async getGoogleDocsByUser(userId: number): Promise<GoogleDoc[]> {
    return await db
      .select()
      .from(googleDocs)
      .where(eq(googleDocs.userId, userId))
      .orderBy(desc(googleDocs.createdAt));
  }
}

export const storage = new DatabaseStorage();
